<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Chat P2P cifrado (WebRTC)</title>
  <style>
    body { font-family: sans-serif; max-width: 800px; margin: 20px auto; }
    textarea { width: 100%; height: 120px; }
    #chat { border: 1px solid #ccc; padding: 10px; height: 200px; overflow-y: auto; margin-bottom: 10px; }
    input, button { margin: 5px 0; }
  </style>
</head>
<body>

  <h1>Chat P2P cifrado</h1>

  <div id="roleSelect">
    <h3>¿Qué rol tienes?</h3>
    <button id="btnEmisor">Emisor (iniciador)</button>
    <button id="btnReceptor">Receptor</button>
  </div>

  <div id="mainUI" style="display:none">
    <h3>1. Contraseña del chat</h3>
    <input type="password" id="passwordInput" placeholder="Introduce contraseña" />
    <button id="savePasswordBtn">Guardar en localStorage</button>
    <p><small>La contraseña se usa para cifrar/descifrar mensajes localmente.</small></p>

    <hr />

    <div id="signalingUI"></div>

    <hr />

    <h3>3. Chat</h3>
    <div id="chat"></div>
    <input type="text" id="messageInput" placeholder="Escribe mensaje" />
    <button id="sendBtn">Enviar</button>
  </div>

  <script>
    // ---------- Utilidades base64 ----------
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = "";
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    // ---------- Cifrado ----------
    const SALT = new TextEncoder().encode("salt-fijo-demo");

    async function getKeyFromPassword(password) {
      const enc = new TextEncoder();
      const passBytes = enc.encode(password);

      const baseKey = await crypto.subtle.importKey(
        "raw",
        passBytes,
        "PBKDF2",
        false,
        ["deriveKey"]
      );

      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt: SALT,
          iterations: 100000,
          hash: "SHA-256",
        },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptMessage(message, key) {
      const enc = new TextEncoder();
      const data = enc.encode(message);

      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );

      const combined = new Uint8Array(iv.byteLength + ciphertext.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(ciphertext), iv.byteLength);

      return arrayBufferToBase64(combined.buffer);
    }

    async function decryptMessage(base64Data, key) {
      const buffer = base64ToArrayBuffer(base64Data);
      const bytes = new Uint8Array(buffer);

      const iv = bytes.slice(0, 12);
      const ciphertext = bytes.slice(12);

      const plaintext = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        key,
        ciphertext
      );

      return new TextDecoder().decode(plaintext);
    }

    // ---------- WebRTC ----------
    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    let pc = null;
    let dataChannel = null;
    let encryptionKey = null;

    const chatDiv = document.getElementById("chat");

    function addMessageToChat(text, from) {
      const p = document.createElement("p");
      p.textContent = from + ": " + text;
      chatDiv.appendChild(p);
      chatDiv.scrollTop = chatDiv.scrollHeight;
    }

    // Esperar a que termine la recogida de ICE y entonces devolver localDescription completa
    function waitForIceGatheringComplete(pc) {
      return new Promise((resolve) => {
        if (pc.iceGatheringState === "complete") {
          resolve();
        } else {
          function checkState() {
            if (pc.iceGatheringState === "complete") {
              pc.removeEventListener("icegatheringstatechange", checkState);
              resolve();
            }
          }
          pc.addEventListener("icegatheringstatechange", checkState);
        }
      });
    }

    function initPeerConnection(isInitiator) {
      pc = new RTCPeerConnection(config);

      if (isInitiator) {
        dataChannel = pc.createDataChannel("chat");
        setupDataChannel();
      }

      pc.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel();
      };
    }

    function setupDataChannel() {
      dataChannel.onopen = () => {
        addMessageToChat("Canal P2P establecido", "Sistema");
      };

      dataChannel.onmessage = async (event) => {
        try {
          if (!encryptionKey) {
            addMessageToChat("[ERROR] No hay clave de cifrado cargada", "Sistema");
            return;
          }
          const decrypted = await decryptMessage(event.data, encryptionKey);
          addMessageToChat(decrypted, "Ellos");
        } catch (e) {
          console.error(e);
          addMessageToChat("[Mensaje recibido pero no se pudo descifrar]", "Sistema");
        }
      };
    }

    // ---------- Señalización dinámica ----------
    const roleSelectDiv = document.getElementById("roleSelect");
    const mainUIDiv = document.getElementById("mainUI");
    const signalingUI = document.getElementById("signalingUI");
    let userRole = null; // 'emisor' o 'receptor'

    document.getElementById("btnEmisor").onclick = () => {
      userRole = "emisor";
      roleSelectDiv.style.display = "none";
      mainUIDiv.style.display = "block";
      renderSignalingUI();
    };
    document.getElementById("btnReceptor").onclick = () => {
      userRole = "receptor";
      roleSelectDiv.style.display = "none";
      mainUIDiv.style.display = "block";
      renderSignalingUI();
    };

    // Estado de señalización
    let signalingStep = 0;

    function renderSignalingUI() {
      signalingUI.innerHTML = "";
      if (userRole === "emisor") {
        if (signalingStep === 0) {
          // Paso 1: crear OFFER
          const btn = document.createElement("button");
          btn.textContent = "Crear OFFER";
          btn.onclick = async () => {
            initPeerConnection(true);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await waitForIceGatheringComplete(pc);
            signalingStep = 1;
            renderSignalingUI();
          };
          signalingUI.appendChild(btn);
        } else if (signalingStep === 1) {
          // Mostrar OFFER para copiar
          const ta = document.createElement("textarea");
          ta.id = "offerOutput";
          ta.placeholder = "Offer generada aquí";
          ta.value = JSON.stringify(pc.localDescription);
          ta.readOnly = true;
          signalingUI.appendChild(document.createTextNode("Copia y envía esta OFFER al receptor:"));
          signalingUI.appendChild(document.createElement("br"));
          signalingUI.appendChild(ta);
          signalingUI.appendChild(document.createElement("br"));

          // Paso siguiente: pegar ANSWER
          const taAns = document.createElement("textarea");
          taAns.id = "answerInput";
          taAns.placeholder = "Pega aquí la ANSWER remota";
          signalingUI.appendChild(document.createTextNode("Pega aquí la ANSWER remota cuando la recibas:"));
          signalingUI.appendChild(document.createElement("br"));
          signalingUI.appendChild(taAns);
          signalingUI.appendChild(document.createElement("br"));
          const btnSetAns = document.createElement("button");
          btnSetAns.textContent = "Usar ANSWER remota";
          btnSetAns.onclick = async () => {
            try {
              const remoteAnswer = JSON.parse(taAns.value);
              await pc.setRemoteDescription(remoteAnswer);
              signalingStep = 2;
              renderSignalingUI();
            } catch (e) {
              alert("Formato de ANSWER inválido");
            }
          };
          signalingUI.appendChild(btnSetAns);
        } else {
          signalingUI.appendChild(document.createTextNode("¡Canal P2P listo!"));
        }
      } else if (userRole === "receptor") {
        if (signalingStep === 0) {
          // Paso 1: pegar OFFER
          const ta = document.createElement("textarea");
          ta.id = "offerInput";
          ta.placeholder = "Pega aquí la OFFER remota";
          signalingUI.appendChild(document.createTextNode("Pega aquí la OFFER que te envía el emisor:"));
          signalingUI.appendChild(document.createElement("br"));
          signalingUI.appendChild(ta);
          signalingUI.appendChild(document.createElement("br"));
          const btnSetOffer = document.createElement("button");
          btnSetOffer.textContent = "Usar OFFER remota";
          btnSetOffer.onclick = async () => {
            try {
              const remoteOffer = JSON.parse(ta.value);
              initPeerConnection(false);
              await pc.setRemoteDescription(remoteOffer);
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              await waitForIceGatheringComplete(pc);
              signalingStep = 1;
              renderSignalingUI();
            } catch (e) {
              alert("Formato de OFFER inválido");
            }
          };
          signalingUI.appendChild(btnSetOffer);
        } else if (signalingStep === 1) {
          // Mostrar ANSWER para copiar
          const ta = document.createElement("textarea");
          ta.id = "answerOutput";
          ta.placeholder = "Answer generada aquí";
          ta.value = JSON.stringify(pc.localDescription);
          ta.readOnly = true;
          signalingUI.appendChild(document.createTextNode("Copia y envía esta ANSWER al emisor:"));
          signalingUI.appendChild(document.createElement("br"));
          signalingUI.appendChild(ta);
          signalingUI.appendChild(document.createElement("br"));
          signalingUI.appendChild(document.createTextNode("¡Canal P2P listo tras enviar la ANSWER!"));
        } else {
          signalingUI.appendChild(document.createTextNode("¡Canal P2P listo!"));
        }
      }
    }

    // ---------- Envío de mensajes ----------
    document.getElementById("sendBtn").onclick = async () => {
      const text = document.getElementById("messageInput").value;
      if (!text) return;

      if (!dataChannel || dataChannel.readyState !== "open") {
        addMessageToChat("No hay canal P2P abierto todavía", "Sistema");
        return;
      }

      if (!encryptionKey) {
        addMessageToChat("No hay contraseña/clave cargada", "Sistema");
        return;
      }

      const encrypted = await encryptMessage(text, encryptionKey);
      dataChannel.send(encrypted);
      addMessageToChat(text, "Tú");
      document.getElementById("messageInput").value = "";
    };

    // ---------- Contraseña ----------
    const passwordInput = document.getElementById("passwordInput");
    const savePasswordBtn = document.getElementById("savePasswordBtn");

    savePasswordBtn.onclick = async () => {
      const pwd = passwordInput.value;
      if (!pwd) return;
      localStorage.setItem("chat-password", pwd);
      encryptionKey = await getKeyFromPassword(pwd);
      addMessageToChat("Contraseña cargada", "Sistema");
    };

    // Cargar automáticamente si ya hay una contraseña almacenada
    const savedPass = localStorage.getItem("chat-password");
    if (savedPass) {
      passwordInput.value = savedPass;
      getKeyFromPassword(savedPass).then(key => {
        encryptionKey = key;
        addMessageToChat("Contraseña cargada desde localStorage", "Sistema");
      });
    }
  </script>
</body>
</html>
